I"ç$<h1 id="whats-up-with-this">What‚Äôs up with this?</h1>

<p>Compilers are insane. They seem to itch both the ‚Äúhow the hell do I program this,‚Äù (engineering) and the ‚Äúhow the hell do I prove this,‚Äù (math) curiosities that I felt I missed from my CS degree at UNSW. That‚Äôs not a jab at UNSW as there‚Äôs plenty of courses that go deep into one of those itches (Advanced Operating Systems I‚Äôm looking at you) but few melded the engineering and math in a way that felt satisfying - courses that came close were Ihor Kuz‚Äôs Distributed Systems and Liam O‚ÄôConnor‚Äôs Programming Languages course. I imagine Computer Graphics would‚Äôve been similarly awesome to take‚Ä¶ but unluckily most of the people who could teach it had left, sadge.</p>

<p>So now I‚Äôm 13 days out from starting my first full-time job, and a personal quest that I promised to myself as a wee 2nd year student - learn as much about compilers as you can. It was the first topic that wow‚Äôd me, presumably because I was head over heels for my ‚Äúnot a Haskell but a Haskell course‚Äù (expertly led by Gabrielle Keller and Liam O‚ÄôConnor) and was probably the first time I experienced that addictive ‚Äúholy shit, that‚Äôs cool‚Äù feeling. So now I‚Äôm going to do 2nd year me proud and continue on that quest - and man oh man, that ‚Äúholy shit, that‚Äôs cool‚Äù feeling just came back.</p>

<h1 id="reaching-definitions">Reaching Definitions</h1>

<p>Given a usage of a variable $x$, which definitions in the program could be responsible for the value that $x$ has? We call these the <em>reaching definitions</em> for $x$ and through exploring the problem we‚Äôll not only come up with an algorithm to this problem, but discover a general framework, providing an almost plug and play solution for other static analyses we‚Äôd want in a compiler.</p>

<!-- CFG -->
<p><img src="/assets/dfa1/basicexample.png" alt="basic cfg" /></p>

<p>The above is a control flow graph (CFG) taken from the lovely <a href="https://ucsd-pl.github.io/cse231/wi18/lectures.html">Dataflow Analysis notes</a> by Sorin Lerner for the UCSD‚Äôs Advanced Compilers course. Don‚Äôt let the ‚Äòadvanced‚Äô scare you! It doesn‚Äôt require previous knowledge, and you can catch his excitement through his oration alone. A CFG is a graph where the nodes are program instructions, and an edge exists from a node V to node W if program control can go from V to W. Our reaching definitions question can then be phrased as: <em>what definitions could have set the value for x, for the usage of x on node 11.</em></p>

<p>Let‚Äôs proceed with a bit of wishful thinking. What type of data structure would be useful to have when on node 11 to figure out which definitions set <code>x</code>? Supposing it was properly formed, we‚Äôd like to keep track of a map from variable name to the possibly setting definitions up to this point. Notice that we‚Äôre talking about a set of definitions, not a single definition, as we‚Äôre a static analysis and can‚Äôt run the code to know which branch gets taken for certain. For example, the usage of <code>x</code> at node 11 could be from nodes 6 or 9‚Ä¶ or 10! For those pondering why 10 can set x, we could have that p contains the address of x.</p>

<!-- update rules -->
<p><img src="/assets/dfa1/rules.png" alt="update rules" /></p>

<p>Updating this set involves traversing through our CFG, and apply rules if the instruction is one of the forms above. We first remove from the set if we‚Äôre sure that this definition will overwrite all others we‚Äôve seen before, and then add our new definition to the set. If we did it the other way around, we‚Äôd remove the definition we just added in. When we have a node that has more than a single input, we merge these sets by taking the set union as definitions could have come from any of these branches.</p>

<p>But then there‚Äôs the question of how to traverse through the CFG? Think about a traversal order that makes sense to you for our example. Our example CFG is not only a graph, but a DAG which means that it has a topological traversal order - for example 12,11,7,6,5,10,9,8,4,3,2,1. So one reasonable way to traverse this DAG is in reverse topological order. This corresponds with our intuition of starting from the entry point of our CFG, and we can guarantee that if we visit a node its inputs have already been visited (verify this with the reverse topological order of the example above).</p>

<!-- loop CFG -->
<p><img src="/assets/dfa1/loopexample.png" alt="loop cfg" /></p>

<p>How does this traversal order fair with the above CFG which models a while loop? It doesn‚Äôt work! We don‚Äôt have a topological order for a graph with cycles. This example differs in that there‚Äôs a cycle - so let‚Äôs try and figure out what the definition set looks like as we go through this cycle!</p>

<!-- iterations -->
<p><img src="/assets/dfa1/loopiter.png" alt="loop iter" /></p>

<p>We stop here as the merge on node 4 for iteration #3 would result in the exact same reaching definition set as iteration #2. When the inputs to a merge were the same as the previous iteration‚Äôs merge, we can safely stop knowing that there‚Äôll be no change to the computed set of reaching definitions. Still, we‚Äôre stuck on the order to process these nodes, with the cycle making it difficult. It‚Äôs a little unintuitive, but if processing order is giving us a hard time - why don‚Äôt we say screw it, and process them in no particular order?</p>

<h2 id="the-worklist-algorithm">The Worklist Algorithm</h2>
<p>For our cycle example, when the input to an instruction changed, we continued processing, and on coming back around and finding that the inputs were the same as the previous iteration, we could safely stop processing. Let‚Äôs assign a function to each instruction (node) thats takes as input the reaching definition set coming into the node, and returns the one going out. We call this a flow function.</p>
<ol>
  <li>For each node, initialise its next input reaching definition set as the empty set (as we‚Äôre not processing these nodes in any order, its as if this is the only instruction in the program hence the reaching definition set would be empty).</li>
  <li>Apply the node‚Äôs associated flow function to the input reaching definition set coming into the node. Where the output feeds in as the input for another instruction, update the input to the next instruction(s).</li>
  <li>Repeat steps 1-2 for nodes that had their inputs change until there are no other nodes to process (all inputs are the same as the previous processing iteration).</li>
</ol>

<p>In code this would look like:</p>
<pre><code class="language-python">for node in nodes:
	IN[node] = empty_set()
do:
	for node in changed(IN, nodes):
		# Update input of node to be union of OUTPUT of the nodes with outgoing 
		# edges pointing to our node.
		IN[node] = union([IN[in_node] for in_node in nodes_with_incoming(node)])
		OUT[node] = apply node's flow function on IN[node]
while(still changes to IN)
</code></pre>

<p>Does this give correct reaching definition sets at each node? Whenever a node detects its input changed, it recomputes the reaching definition set and sets its new output to that. If that node had an outgoing edge to another node, and if the output had changed from what it previously was, then it‚Äôll force those nodes to recompute. Eventually we‚Äôll reach a state where all nodes have converged on the state of their inputs, and if not, then the nodes we‚Äôre waiting on will eventually update themselves.</p>

<p>Another way to see this is that we‚Äôre treating the CFG as a big dependency graph. When one of the node‚Äôs output changes, we update all of the nodes that depended on that output as input and so on.</p>

<p>However, the ‚Äústill changes‚Äù while loop condition gives us pause. Does this terminate? Since we‚Äôre using unions that will monotonically increase the set size, can we keep on adding definitions and never stop? This algorithm terminates as there‚Äôs a finite number of variable names, as well as a finite number of instructions so the set‚Äôs size is bounded by <code>numVariableNamesInProgram * numInstructions</code>, but for real programs it‚Äôs safe to say we wouldn‚Äôt come close to this size!</p>

<h1 id="wrapping-up">Wrapping Up</h1>

<p>I found the leap from thinking about reverse-topological processing order to no order and recompute your flow function output when your input changes to be difficult to accept. It‚Äôs difficult to accept in the same way as when you look at a difficult step in the proof, and the next step is a leap of logic that you‚Äôd never get on your own. Compilers are full of this stuff and despite feeling a little clueless, taking the leap into the difficult step makes it easier to see things like that later down the track. Check out <a href="https://ucsd-pl.github.io/cse231/wi20/project.html">UCSD‚Äôs CSE231</a> for projects you can wrangle with along these lines.</p>

<p>The next article in this series will generalise our solution, and be able to apply our generalisation as a framework to solve other optimisation problems like, constant propagation, or figuring out whether a variable is live. We‚Äôll dive into lattice structures, fixpoint theory, and finally give a name to this way of looking at problems - Dataflow Analysis.</p>
:ET